---
title: 蓝牙
date: 2020-01-12 11:49:16
permalink: /pages/0796ba76b4b55368
categories:
  - 《Bluetooth 范围｜蓝牙®开发实践指北》笔记
tags:
  - JavaScript
author:
  name: Coder Bruce
  link: https://bruceyou.notion.site/Coder-Bruce-5a8c1717a6d048b9bcaadf95281f1159
---

> 本文为本人原创作品，版权归本人所有。未经本人授权，任何人不得转载、抄袭、摘编或以任何其他方式使用本文。如需转载或引用，请在明确授权的前提下注明出处及作者信息，违者必追究法律责任。


## 蓝牙技术概述

蓝牙技术是一种无线通信技术，用于在短距离内传输数据。它可以通过电子设备之间的短距离无线通信来实现数据传输和连接。

## 起源和发展历史

蓝牙技术的起源可以追溯到1994年，当时瑞典的爱立信公司开始研究无线数据通信技术，以解决移动设备之间数据传输的问题。1998年，爱立信、IBM、英特尔、诺基亚和东芝等公司成立了蓝牙特别兴趣小组（SIG），开始研究蓝牙技术的标准化。

2000年，蓝牙技术1.0版发布，支持数据传输速率为1Mbps。随后，蓝牙技术逐渐发展，推出了2.0版、3.0版、4.0版和5.0版等不同版本，提高了数据传输速率和连接稳定性，同时也增加了新的功能。

### 蓝牙技术1.0版：
于1999年7月发布，支持数据传输速率为1Mbps，距离为10米左右，主要用于连接手机和耳机等简单的设备。 
### 蓝牙技术1.1版：
于2001年2月发布，增加了连接安全性和音频质量控制等功能。 
蓝牙技术1.2版：于2003年11月发布，支持快速连接和自适应频率跳跃等新特性，提高了连接速度和连接质量。 
### 蓝牙技术2.0版：
于2004年11月发布，支持增强数据速率（EDR）技术，提高了数据传输速率到3Mbps，同时支持更长的距离范围。 
### 蓝牙技术2.1版：
于2007年7月发布，增加了简化配对过程、降低功耗和增强安全性等新特性。 
### 蓝牙技术3.0版：
于2009年4月发布，引入了高速数据传输（HS）技术，支持最高传输速率24Mbps，同时保持向后兼容性。 External Accessory框架最初是在2019年iOS 3.0版本中引入的，作为Apple MFi计划的一部分，旨在为开发人员提供一种与iOS设备通信的标准接口。这个计划的目标是确保第三方硬件和iOS设备之间的兼容性，同时保护苹果公司的知识产权和用户体验。自2010年以来，苹果公司已经授权超过1000个硬件制造商加入MFi计划，并推出了多种可与iOS设备兼容的外部设备，包括打印机、游戏控制器、音频设备、医疗设备等。

- 以下是一个使用External Accessory框架连接并与外部设备通信的示例代码，其中用中文添加了注释：

```
objectiveCopy code
// 导入ExternalAccessory框架
#import <ExternalAccessory/ExternalAccessory.h>

@interface ViewController : UIViewController <EAAccessoryDelegate, NSStreamDelegate>

// 设备连接相关的属性
@property (nonatomic, strong) EASession *session;
@property (nonatomic, strong) EAAccessory *accessory;
@property (nonatomic, strong) NSMutableArray *inputDataBuffer;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 初始化输入数据缓冲区
    self.inputDataBuffer = [[NSMutableArray alloc] init];
    
    // 查找支持的外部设备并建立连接
    NSArray *accessories = [[EAAccessoryManager sharedAccessoryManager] connectedAccessories];
    for (EAAccessory *accessory in accessories) {
        if ([self isAccessorySupported:accessory]) {
            [self connectToAccessory:accessory];
            break;
        }
    }
}

// 判断设备是否支持
- (BOOL)isAccessorySupported:(EAAccessory *)accessory {
    // 检查设备是否符合我们的要求，返回true或false
    return YES;
}

// 建立与设备的连接
- (void)connectToAccessory:(EAAccessory *)accessory {
    // 设置accessory属性，用于后续的通信
    self.accessory = accessory;
    
    // 为设备设置代理
    accessory.delegate = self;
    
    // 获取设备通信的协议
    NSArray *protocols = accessory.protocolStrings;
    NSString *protocolString = [protocols objectAtIndex:0];
    
    // 创建输入和输出流
    self.session = [[EASession alloc] initWithAccessory:self.accessory forProtocol:protocolString];
    if (self.session) {
        self.session.inputStream.delegate = self;
        [self.session.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
        [self.session.inputStream open];
        [self.session.outputStream open];
    }
}

// 设备连接成功后的回调方法
- (void)accessoryDidConnect:(EAAccessory *)accessory {
    if ([self isAccessorySupported:accessory]) {
        [self connectToAccessory:accessory];
    }
}

// 设备断开连接后的回调方法
- (void)accessoryDidDisconnect:(EAAccessory *)accessory {
    if ([accessory isEqual:self.accessory]) {
        [self disconnectFromAccessory];
    }
}

// 断开与设备的连接
- (void)disconnectFromAccessory {
    [self.session.inputStream close];
    [self.session.inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
    self.session.inputStream.delegate = nil;
    [self.session.outputStream close];
    self.session.outputStream = nil;
    self.session.inputStream = nil;
    self.session = nil;
}

- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {
    switch (eventCode) {
        case NSStreamEventHasBytesAvailable: {
            // 读取数据流并将数据存入输入数据缓冲区
            uint8_t buf[1024];
            NSInteger len = 0;
            len = [self.session.inputStream read:buf maxLength:1024];
            if (len > 0) {
                NSData *data = [NSData dataWithBytes:buf length:len];
                [self.inputDataBuffer addObject:data];
            }
            break;
        }
        case NSStreamEventEndEncountered: {
            // 关闭流并断开与设备的连接
            [self disconnectFromAccessory];
            break;
        }
        default:
            break;
    }
}

           
```

ExternalAccessory主要用于连接通过传统的蓝牙连接方式与iOS设备通信的设备，如车载系统、音频设备等。这些设备通常使用传统的串口通信协议进行数据交换。ExternalAccessory框架提供了一个简单的接口来管理外部设备的连接和通信。

CoreBluetooth则是为连接使用低功耗蓝牙（BLE）协议的设备而设计的，这些设备通常包括健康追踪设备、智能家居设备、智能手表等。BLE协议使用了完全不同的通信协议，因此CoreBluetooth提供了一个完整的BLE协议栈来管理设备的连接和通信。

从开发角度来说，使用ExternalAccessory框架需要先获取外部设备的访问权限，并且在应用程序中显式声明支持的外部设备。而使用CoreBluetooth框架则需要实现BLE协议栈中的多个层次来实现设备的连接和通信。

因此，尽管ExternalAccessory和CoreBluetooth都是用于iOS设备与外部蓝牙设备进行通信的框架，但它们在连接的设备类型、通信协议、开发模型和编程接口等方面有着较大的区别。在实际开发中，开发人员需要根据具体的应用场景和需要，选择合适的框架来进行开发。
#### ExternalAccessory 框架中，并没有使用 UUID、服务和特征的概念
在 ExternalAccessory 框架中，并没有使用 UUID、服务和特征的概念，而是使用 EAAccessory 类和 EASession 类来实现外部附件设备的连接和通信。

EAAccessory 类代表了一个外部附件设备，它包含了设备的基本信息，如设备名称、制造商、序列号等，以及与设备通信所需的一些属性和方法，如设备连接状态、输入输出流等。

EASession 类代表了与设备的一次通信会话，它包含了输入流和输出流，用于与设备进行双向数据传输。 EASession 类的初始化需要指定一个外部附件设备（EAAccessory 类的实例），而不是通过 UUID、服务和特征来连接设备。

```
// 导入ExternalAccessory框架
#import <ExternalAccessory/ExternalAccessory.h>

@interface ViewController : UIViewController <EAAccessoryDelegate>

// 设备连接相关的属性
@property (nonatomic, strong) EASession *session;
@property (nonatomic, strong) EAAccessory *accessory;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 查找支持的外部设备并建立连接
    NSArray *accessories = [[EAAccessoryManager sharedAccessoryManager] connectedAccessories];
    for (EAAccessory *accessory in accessories) {
        if ([self isAccessorySupported:accessory]) {
            [self connectToAccessory:accessory];
            break;
        }
    }
}

// 判断设备是否支持
- (BOOL)isAccessorySupported:(EAAccessory *)accessory {
    // 检查设备是否符合我们的要求，返回true或false
    return YES;
}

// 建立与设备的连接
- (void)connectToAccessory:(EAAccessory *)accessory {
    // 设置accessory属性，用于后续的通信
    self.accessory = accessory;
    
    // 为设备设置代理
    accessory.delegate = self;
    
    // 获取设备的基本信息
    NSString *name = accessory.name;
    NSString *manufacturer = accessory.manufacturer;
    NSString *serialNumber = accessory.serialNumber;
    NSString *modelNumber = accessory.modelNumber;
    NSString *hardwareRevision = accessory.hardwareRevision;
    NSString *firmwareRevision = accessory.firmwareRevision;
    
    // 输出设备信息
    NSLog(@"设备名称：%@", name);
    NSLog(@"设备制造商：%@", manufacturer);
    NSLog(@"设备序列号：%@", serialNumber);
    NSLog(@"设备型号：%@", modelNumber);
    NSLog(@"硬件版本号：%@", hardwareRevision);
    NSLog(@"固件版本号：%@", firmwareRevision);
}

// 设备连接成功后的回调方法
- (void)accessoryDidConnect:(EAAccessory *)accessory {
    if ([self isAccessorySupported:accessory]) {
        [self connectToAccessory:accessory];
    }
}

// 设备断开连接后的回调方法
- (void)accessoryDidDisconnect:(EAAccessory *)accessory {
    if ([accessory isEqual:self.accessory]) {
        [self disconnectFromAccessory];
    }
}

// 断开与设备的连接
- (void)disconnectFromAccessory {
    [self.session.inputStream close];
    [self.session.inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
    self.session.inputStream.delegate = nil;
    [self.session.outputStream close];
    self.session.outputStream = nil;
    self.session.inputStream = nil;
    self.session = nil;
}

```




### 蓝牙技术4.0版：
于2010年6月发布，引入了低能耗（LE）技术，支持更低的功耗和更广泛的应用范围，例如健康监测、运动追踪等。 在iOS 5中，苹果公司首次引入了Core Bluetooth框架，该框架使得iOS设备能够使用蓝牙4.0及以上版本进行通信。在之后的iOS版本中，Core Bluetooth框架也得到了更新和改进，以支持新的蓝牙技术版本和新的应用场景。

使用CoreBluetooth框架实现两个设备之间的蓝牙通信：

```
objectiveCopy code
// 导入CoreBluetooth框架
#import <CoreBluetooth/CoreBluetooth.h>

@interface ViewController : UIViewController <CBCentralManagerDelegate, CBPeripheralDelegate>

// 设备连接相关的属性
@property (nonatomic, strong) CBCentralManager *centralManager;
@property (nonatomic, strong) CBPeripheral *peripheral;
@property (nonatomic, strong) CBCharacteristic *writeCharacteristic;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 初始化蓝牙中心设备管理器
    self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
}

// 扫描周围的外设
- (void)scanForPeripherals {
    NSDictionary *options = [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:NO] forKey:CBCentralManagerScanOptionAllowDuplicatesKey];
    [self.centralManager scanForPeripheralsWithServices:nil options:options];
}

// 开始连接外设
- (void)connectPeripheral:(CBPeripheral *)peripheral {
    [self.centralManager connectPeripheral:peripheral options:nil];
}

// 连接成功后发现外设的服务和特征
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error {
    if (error) {
        return;
    }
    
    for (CBService *service in peripheral.services) {
        [peripheral discoverCharacteristics:nil forService:service];
    }
}

// 发现特征后进行数据写入
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error {
    if (error) {
        return;
    }
    
    for (CBCharacteristic *characteristic in service.characteristics) {
        if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"]]) {
            self.writeCharacteristic = characteristic;
        }
    }
    
    // 写入数据
    NSData *data = [@"Hello World!" dataUsingEncoding:NSUTF8StringEncoding];
    [self.peripheral writeValue:data forCharacteristic:self.writeCharacteristic type:CBCharacteristicWriteWithResponse];
}

// 发现外设后连接它
- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary<NSString *,id> *)advertisementData RSSI:(NSNumber *)RSSI {
    self.peripheral = peripheral;
    [self.centralManager stopScan];
    [self connectPeripheral:peripheral];
}

// 连接成功后发现外设的服务和特征
- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral {
    peripheral.delegate = self;
    [peripheral discoverServices:nil];
}

@end
```

蓝牙特征和服务的概念是在蓝牙4.0版本中引入的，该版本引入了GATT协议（Generic Attribute Profile）和ATT协议（Attribute Protocol），并且定义了GATT和ATT的基本操作和通信流程。在GATT协议中，定义了蓝牙服务和特征的概念，并规定了它们的UUID格式和属性。例如，服务的UUID格式为16个字节，特征的UUID格式为16个字节的短UUID或128个字节的UUID。同时，还规定了一些标准的服务和特征的UUID和属性，例如心率服务、电池服务等。这些服务和特征的UUID和属性是由SIG（蓝牙特别兴趣小组）定义和维护的。

#### Apple Google Windows 三个平台对应GATT协议的核心描述：

Apple [Core Bluetooth Overview](https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html#//apple_ref/doc/uid/TP40013257-CH2-SW1) 

Google  [BluetoothGatt](https://developer.android.com/reference/android/bluetooth/BluetoothGatt)

Windows [Windows.Devices.Bluetooth.GenericAttributeProfile Namespace](https://learn.microsoft.com/en-us/uwp/api/windows.devices.bluetooth.genericattributeprofile?view=winrt-22000)

爱立信、IBM、英特尔、诺基亚和东芝都是蓝牙技术联盟（Bluetooth Special Interest Group，简称SIG）
他们一起制定了蓝牙GATT协议的相关标准。GATT协议定义了蓝牙设备之间进行通信时，如何交换数据和使用服务和特征的概念。

在GATT协议中，服务（Service）是一组相关特征的集合，用于描述蓝牙设备所提供的功能。每个服务都有一个唯一的服务UUID用于标识该服务。特征（Characteristic）是服务中的一个数据单元，它包含了一个值和一些属性，用于描述蓝牙设备提供的具体功能。每个特征都有一个唯一的特征UUID用于标识该特征。

爱立信、IBM、英特尔、诺基亚和东芝在制定GATT协议时，主要关注以下几个方面：

服务和特征的定义：他们定义了服务和特征的概念，并明确了服务UUID和特征UUID的作用和含义。

数据格式：他们规定了蓝牙设备之间交换数据的格式，包括传输的数据类型、编码方式和字节序等。

安全性：他们考虑了蓝牙设备之间通信时的安全性问题，并定义了一些安全机制和措施，如加密、认证和授权等。
###  蓝牙技术4.1版：
于2013年12月发布，增加了更强大的数据传输和连接稳定性，同时支持多连接和更快的设备发现。 
### 蓝牙技术4.2版：
于2014年12月发布，增加了更安全和更快速的数据传输，同时支持物联网（IoT）和低功耗广域网（LPWAN）应用。 
###  蓝牙技术5.0版：
于2016年12月发布，引入了低功耗长距离（LE Long Range）技术，支持更长的距离范围和更高的传输速率，同时支持音频传输、广告传输和位置服务等新功"每个版本下iOS开发的框架有什么变化 三级markdown文档展示



## 解决的问题

蓝牙技术的发明旨在解决电子设备之间的数据传输和连接问题。传统的有线连接方式存在着很多局限性，如连接不方便、布线麻烦等。而蓝牙技术的出现，使得设备之间可以进行无线连接，从而解决了这些问题。

## 主要应用领域

蓝牙技术被广泛应用于以下领域：

- 个人消费电子产品，如手机、笔记本电脑、平板电脑、耳机等；
- 家庭自动化设备，如智能门锁、智能灯泡、智能插座等；
- 医疗保健领域，如心率监测器、血糖监测器、智能健康手环等；
- 汽车行业，如蓝牙车载电话、蓝牙音乐播放器等。

## 标准化和推广

蓝牙技术的标准化和推广是由蓝牙特别兴趣小组（SIG）来负责的。该组织定期发布蓝牙技术的新版本，并向公众和电子设备制造商宣传蓝牙技术的优势和使用方法。此外，蓝牙技术也得到了多个国际标准化组织的认可和支持，如IEEE、ISO和ETSI等。

## 对人们生活方式的影响

蓝牙技术的出现使得人们在电子设备之间进行数据传输和连接变得更加便捷和快速。通过蓝牙技术，人们可以使用无线耳机、智能手环、智能手表等设备，使得生活更加便捷和舒适。

蓝牙技术的广泛应用也为商业和社交交流提供了新的可能性。例如，在商业领域，人们可以使用蓝牙技术进行电子支付、手机购物、实时定位等。在社交领域，人们可以使用蓝牙技术连接到其他设备，分享照片、音乐等信息。

## 未来发展趋势和新的应用领域

随着物联网和智能家居的发展，蓝牙技术的应用范围将进一步扩大。未来，蓝牙技术将被广泛应用于智能家居、智能健康、智能车辆等新兴技术领域。例如，人们可以通过蓝牙技术连接智能家居设备，控制灯光、温度、音响等，实现智能化生活。在智能健康领域，人们可以使用蓝牙技术连接各种健康监测设备，如心率监测器、血压计、体温计等，实时监测身体状况。此外，在智能车辆领域，人们可以使用蓝牙技术进行车内音响控制、车载电话等操作。

总之，蓝牙技术作为一种广泛应用的无线通信技术，不断发展和创新，将在未来为人们的生活、工作和社交带来更多的便利和创新。
